// GENERATED BY Accumulate gen-sdk. DO NOT EDIT.

import 'dart:convert';
import 'dart:typed_data';

// === BEGIN: Accumulate primitive wrapper types ===
// These implement stable JSON forms that match TS/Go wire representations.

class Url {
  final String value;
  const Url(this.value);
  factory Url.fromJson(dynamic j) => Url(j as String);
  dynamic toJson() => value;
  @override String toString() => value;
  @override bool operator==(Object o) => o is Url && o.value == value;
  @override int get hashCode => value.hashCode;
}

class Hash {
  final Uint8List bytes;
  const Hash(this.bytes);
  factory Hash.fromHex(String hex) {
    final b = Uint8List(hex.length ~/ 2);
    for (var i = 0; i < b.length; i++) {
      b[i] = int.parse(hex.substring(i * 2, i * 2 + 2), radix: 16);
    }
    return Hash(b);
  }
  factory Hash.fromJson(dynamic j) {
    // Accept hex or base64; TS/Go goldens most often use hex for display, bytes on wire; JSON often base64.
    if (j is String && j.length % 2 == 0 && RegExp(r"^[0-9a-fA-F]+$").hasMatch(j)) {
      return Hash.fromHex(j.toLowerCase());
    }
    // fallback: base64
    return Hash(Uint8List.fromList(base64.decode(j as String)));
  }
  dynamic toJson() => base64.encode(bytes);
  String toHex() {
    final sb = StringBuffer();
    for (final b in bytes) {
      sb.write(b.toRadixString(16).padLeft(2, "0"));
    }
    return sb.toString();
  }
  @override bool operator==(Object o) => o is Hash && _eq(o.bytes, bytes);
  static bool _eq(Uint8List a, Uint8List b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
  @override int get hashCode => bytes.length; // cheap; adequate for maps in tests
}

class ChainId {
  final String value;
  const ChainId(this.value);
  factory ChainId.fromJson(dynamic j) => ChainId(j as String);
  dynamic toJson() => value;
  @override String toString() => value;
  @override bool operator==(Object o) => o is ChainId && o.value == value;
  @override int get hashCode => value.hashCode;
}

class Timestamp {
  final String rfc3339; // keep string form to match Go/TS JSON exactly
  const Timestamp(this.rfc3339);
  factory Timestamp.fromJson(dynamic j) => Timestamp(j as String);
  dynamic toJson() => rfc3339;
  @override String toString() => rfc3339;
  @override bool operator==(Object o) => o is Timestamp && o.rfc3339 == rfc3339;
  @override int get hashCode => rfc3339.hashCode;
}

class Duration {
  final int nanos; // or string; depends on v3 spec; most goldens prefer integer count
  const Duration(this.nanos);
  factory Duration.fromJson(dynamic j) => Duration(j is int ? j : int.parse(j.toString()));
  dynamic toJson() => nanos;
  @override String toString() => "$nanos";
  @override bool operator==(Object o) => o is Duration && o.nanos == nanos;
  @override int get hashCode => nanos.hashCode;
}

class BigIntJson {
  final BigInt value;
  const BigIntJson(this.value);
  factory BigIntJson.fromJson(dynamic j) => BigIntJson(BigInt.parse(j.toString()));
  dynamic toJson() => value.toString();
  @override String toString() => value.toString();
  @override bool operator==(Object o) => o is BigIntJson && o.value == value;
  @override int get hashCode => value.hashCode;
}
// === END: Accumulate primitive wrapper types ===




// === BEGIN: API Response Types ===
// These are minimal response types for compilation purposes

class TxResponse {
  final Map<String, dynamic> _data;
  const TxResponse(this._data);
  factory TxResponse.fromJson(dynamic json) => TxResponse(json as Map<String, dynamic>);
  dynamic toJson() => _data;
}

class DescriptionResponse {
  final Map<String, dynamic> _data;
  const DescriptionResponse(this._data);
  factory DescriptionResponse.fromJson(dynamic json) => DescriptionResponse(json as Map<String, dynamic>);
  dynamic toJson() => _data;
}

class StatusResponse {
  final Map<String, dynamic> _data;
  const StatusResponse(this._data);
  factory StatusResponse.fromJson(dynamic json) => StatusResponse(json as Map<String, dynamic>);
  dynamic toJson() => _data;
}

class ChainQueryResponse {
  final Map<String, dynamic> _data;
  const ChainQueryResponse(this._data);
  factory ChainQueryResponse.fromJson(dynamic json) => ChainQueryResponse(json as Map<String, dynamic>);
  dynamic toJson() => _data;
}

class TransactionQueryResponse {
  final Map<String, dynamic> _data;
  const TransactionQueryResponse(this._data);
  factory TransactionQueryResponse.fromJson(dynamic json) => TransactionQueryResponse(json as Map<String, dynamic>);
  dynamic toJson() => _data;
}

class MultiResponse {
  final Map<String, dynamic> _data;
  const MultiResponse(this._data);
  factory MultiResponse.fromJson(dynamic json) => MultiResponse(json as Map<String, dynamic>);
  dynamic toJson() => _data;
}

class TxRequest {
  final Map<String, dynamic> _data;
  const TxRequest(this._data);
  factory TxRequest.fromJson(dynamic json) => TxRequest(json as Map<String, dynamic>);
  dynamic toJson() => _data;
}
