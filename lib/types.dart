// GENERATED BY Accumulate gen-sdk. DO NOT EDIT.

import 'dart:convert';
import 'dart:typed_data';

// Import compatibility aliases for generated client
import 'src/protocol.dart' as protocol;
import 'src/api.dart' as api;

// === BEGIN: Accumulate primitive wrapper types ===
// These implement stable JSON forms that match TS/Go wire representations.

class Url {
  final String value;
  const Url(this.value);
  factory Url.fromJson(dynamic j) => Url(j as String);
  dynamic toJson() => value;
  @override
  String toString() => value;
  @override
  bool operator ==(Object o) => o is Url && o.value == value;
  @override
  int get hashCode => value.hashCode;
}

class Hash {
  final Uint8List bytes;
  const Hash(this.bytes);
  factory Hash.fromHex(String hex) {
    final b = Uint8List(hex.length ~/ 2);
    for (var i = 0; i < b.length; i++) {
      b[i] = int.parse(hex.substring(i * 2, i * 2 + 2), radix: 16);
    }
    return Hash(b);
  }
  factory Hash.fromJson(dynamic j) {
    // Accept hex or base64; TS/Go goldens most often use hex for display, bytes on wire; JSON often base64.
    if (j is String &&
        j.length % 2 == 0 &&
        RegExp(r"^[0-9a-fA-F]+$").hasMatch(j)) {
      return Hash.fromHex(j.toLowerCase());
    }
    // fallback: base64
    return Hash(Uint8List.fromList(base64.decode(j as String)));
  }
  dynamic toJson() => base64.encode(bytes);
  String toHex() {
    final sb = StringBuffer();
    for (final b in bytes) {
      sb.write(b.toRadixString(16).padLeft(2, "0"));
    }
    return sb.toString();
  }

  @override
  bool operator ==(Object o) => o is Hash && _eq(o.bytes, bytes);
  static bool _eq(Uint8List a, Uint8List b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  @override
  int get hashCode => bytes.length; // cheap; adequate for maps in tests
}

class ChainId {
  final String value;
  const ChainId(this.value);
  factory ChainId.fromJson(dynamic j) => ChainId(j as String);
  dynamic toJson() => value;
  @override
  String toString() => value;
  @override
  bool operator ==(Object o) => o is ChainId && o.value == value;
  @override
  int get hashCode => value.hashCode;
}

class Timestamp {
  final String rfc3339; // keep string form to match Go/TS JSON exactly
  const Timestamp(this.rfc3339);
  factory Timestamp.fromJson(dynamic j) => Timestamp(j as String);
  dynamic toJson() => rfc3339;
  @override
  String toString() => rfc3339;
  @override
  bool operator ==(Object o) => o is Timestamp && o.rfc3339 == rfc3339;
  @override
  int get hashCode => rfc3339.hashCode;
}

class Duration {
  final int
      nanos; // or string; depends on v3 spec; most goldens prefer integer count
  const Duration(this.nanos);
  factory Duration.fromJson(dynamic j) =>
      Duration(j is int ? j : int.parse(j.toString()));
  dynamic toJson() => nanos;
  @override
  String toString() => "$nanos";
  @override
  bool operator ==(Object o) => o is Duration && o.nanos == nanos;
  @override
  int get hashCode => nanos.hashCode;
}

class BigIntJson {
  final BigInt value;
  const BigIntJson(this.value);
  factory BigIntJson.fromJson(dynamic j) =>
      BigIntJson(BigInt.parse(j.toString()));
  dynamic toJson() => value.toString();
  @override
  String toString() => value.toString();
  @override
  bool operator ==(Object o) => o is BigIntJson && o.value == value;
  @override
  int get hashCode => value.hashCode;
}
// === END: Accumulate primitive wrapper types ===

// Placeholder API type definitions
// These would be generated from the API spec if the spec had proper type definitions
class TxRequest {
  final Map<String, dynamic> data;
  const TxRequest(this.data);
  factory TxRequest.fromJson(Map<String, dynamic> json) => TxRequest(json);
  Map<String, dynamic> toJson() => data;
}

class TxResponse {
  final Map<String, dynamic> data;
  const TxResponse(this.data);
  factory TxResponse.fromJson(Map<String, dynamic> json) => TxResponse(json);
  Map<String, dynamic> toJson() => data;
}

class DescriptionResponse {
  final Map<String, dynamic> data;
  const DescriptionResponse(this.data);
  factory DescriptionResponse.fromJson(Map<String, dynamic> json) =>
      DescriptionResponse(json);
  Map<String, dynamic> toJson() => data;
}

class SubmitRequest {
  final Map<String, dynamic> data;
  const SubmitRequest(this.data);
  factory SubmitRequest.fromJson(Map<String, dynamic> json) =>
      SubmitRequest(json);
  Map<String, dynamic> toJson() => data;
}

class SubmitResponse {
  final Map<String, dynamic> data;
  const SubmitResponse(this.data);
  factory SubmitResponse.fromJson(Map<String, dynamic> json) =>
      SubmitResponse(json);
  Map<String, dynamic> toJson() => data;
}

class BlockQuery {
  final Map<String, dynamic> data;
  const BlockQuery(this.data);
  factory BlockQuery.fromJson(Map<String, dynamic> json) => BlockQuery(json);
  Map<String, dynamic> toJson() => data;
}

class BlockResponse {
  final Map<String, dynamic> data;
  const BlockResponse(this.data);
  factory BlockResponse.fromJson(Map<String, dynamic> json) =>
      BlockResponse(json);
  Map<String, dynamic> toJson() => data;
}

class ChainQuery {
  final Map<String, dynamic> data;
  const ChainQuery(this.data);
  factory ChainQuery.fromJson(Map<String, dynamic> json) => ChainQuery(json);
  Map<String, dynamic> toJson() => data;
}

class ChainResponse {
  final Map<String, dynamic> data;
  const ChainResponse(this.data);
  factory ChainResponse.fromJson(Map<String, dynamic> json) =>
      ChainResponse(json);
  Map<String, dynamic> toJson() => data;
}

class Query {
  final Map<String, dynamic> data;
  const Query(this.data);
  factory Query.fromJson(Map<String, dynamic> json) => Query(json);
  Map<String, dynamic> toJson() => data;
}

class Record {
  final Map<String, dynamic> data;
  const Record(this.data);
  factory Record.fromJson(Map<String, dynamic> json) => Record(json);
  Map<String, dynamic> toJson() => data;
}

// Additional placeholder types for generated client
class GeneralQuery {
  final Map<String, dynamic> data;
  const GeneralQuery(this.data);
  factory GeneralQuery.fromJson(Map<String, dynamic> json) =>
      GeneralQuery(json);
  Map<String, dynamic> toJson() => data;
}

class DataEntryQuery {
  final Map<String, dynamic> data;
  const DataEntryQuery(this.data);
  factory DataEntryQuery.fromJson(Map<String, dynamic> json) =>
      DataEntryQuery(json);
  Map<String, dynamic> toJson() => data;
}

class DirectoryQuery {
  final Map<String, dynamic> data;
  const DirectoryQuery(this.data);
  factory DirectoryQuery.fromJson(Map<String, dynamic> json) =>
      DirectoryQuery(json);
  Map<String, dynamic> toJson() => data;
}

class RangeOptions {
  final Map<String, dynamic> data;
  const RangeOptions(this.data);
  factory RangeOptions.fromJson(Map<String, dynamic> json) =>
      RangeOptions(json);
  Map<String, dynamic> toJson() => data;
}

class ChainQueryResponse {
  final Map<String, dynamic> data;
  const ChainQueryResponse(this.data);
  factory ChainQueryResponse.fromJson(Map<String, dynamic> json) =>
      ChainQueryResponse(json);
  Map<String, dynamic> toJson() => data;
}

class TransactionQueryResponse {
  final Map<String, dynamic> data;
  const TransactionQueryResponse(this.data);
  factory TransactionQueryResponse.fromJson(Map<String, dynamic> json) =>
      TransactionQueryResponse(json);
  Map<String, dynamic> toJson() => data;
}

class MultiResponse {
  final Map<String, dynamic> data;
  const MultiResponse(this.data);
  factory MultiResponse.fromJson(Map<String, dynamic> json) =>
      MultiResponse(json);
  Map<String, dynamic> toJson() => data;
}

// Missing types needed by generated client
class ExecuteRequest {
  final Map<String, dynamic> data;
  const ExecuteRequest(this.data);
  factory ExecuteRequest.fromJson(Map<String, dynamic> json) =>
      ExecuteRequest(json);
  Map<String, dynamic> toJson() => data;
}

class MetricsQuery {
  final Map<String, dynamic> data;
  const MetricsQuery(this.data);
  factory MetricsQuery.fromJson(Map<String, dynamic> json) =>
      MetricsQuery(json);
  Map<String, dynamic> toJson() => data;
}

class DataEntrySetQuery {
  final Map<String, dynamic> data;
  const DataEntrySetQuery(this.data);
  factory DataEntrySetQuery.fromJson(Map<String, dynamic> json) =>
      DataEntrySetQuery(json);
  Map<String, dynamic> toJson() => data;
}

class KeyPageIndexQuery {
  final Map<String, dynamic> data;
  const KeyPageIndexQuery(this.data);
  factory KeyPageIndexQuery.fromJson(Map<String, dynamic> json) =>
      KeyPageIndexQuery(json);
  Map<String, dynamic> toJson() => data;
}

class MajorBlocksQuery {
  final Map<String, dynamic> data;
  const MajorBlocksQuery(this.data);
  factory MajorBlocksQuery.fromJson(Map<String, dynamic> json) =>
      MajorBlocksQuery(json);
  Map<String, dynamic> toJson() => data;
}

class MinorBlocksQuery {
  final Map<String, dynamic> data;
  const MinorBlocksQuery(this.data);
  factory MinorBlocksQuery.fromJson(Map<String, dynamic> json) =>
      MinorBlocksQuery(json);
  Map<String, dynamic> toJson() => data;
}

class SyntheticTransactionRequest {
  final Map<String, dynamic> data;
  const SyntheticTransactionRequest(this.data);
  factory SyntheticTransactionRequest.fromJson(Map<String, dynamic> json) =>
      SyntheticTransactionRequest(json);
  Map<String, dynamic> toJson() => data;
}

class TxnQuery {
  final Map<String, dynamic> data;
  const TxnQuery(this.data);
  factory TxnQuery.fromJson(Map<String, dynamic> json) => TxnQuery(json);
  Map<String, dynamic> toJson() => data;
}

class TxHistoryQuery {
  final Map<String, dynamic> data;
  const TxHistoryQuery(this.data);
  factory TxHistoryQuery.fromJson(Map<String, dynamic> json) =>
      TxHistoryQuery(json);
  Map<String, dynamic> toJson() => data;
}

class StatusResponse {
  final Map<String, dynamic> data;
  const StatusResponse(this.data);
  factory StatusResponse.fromJson(Map<String, dynamic> json) =>
      StatusResponse(json);
  Map<String, dynamic> toJson() => data;
}
